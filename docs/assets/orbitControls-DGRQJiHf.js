function _(){const c=new Float32Array([-1,-1,1,0,0,1,1,-1,1,0,0,1,1,1,1,0,0,1,-1,1,1,0,0,1,1,-1,-1,0,0,-1,-1,-1,-1,0,0,-1,-1,1,-1,0,0,-1,1,1,-1,0,0,-1,-1,1,1,0,1,0,1,1,1,0,1,0,1,1,-1,0,1,0,-1,1,-1,0,1,0,-1,-1,-1,0,-1,0,1,-1,-1,0,-1,0,1,-1,1,0,-1,0,-1,-1,1,0,-1,0,1,-1,1,1,0,0,1,-1,-1,1,0,0,1,1,-1,1,0,0,1,1,1,1,0,0,-1,-1,-1,-1,0,0,-1,-1,1,-1,0,0,-1,1,1,-1,0,0,-1,1,-1,-1,0,0]),t=new Uint16Array([0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23]);return{vertices:c,indices:t}}function m(c=1,t=16,s=12){const a=[],e=[];for(let n=0;n<=s;n++)for(let o=0;o<=t;o++){const h=o/t,u=n/s,p=h*Math.PI*2,r=u*Math.PI,d=-c*Math.sin(r)*Math.cos(p),M=c*Math.cos(r),v=c*Math.sin(r)*Math.sin(p),f=d/c,l=M/c,y=v/c;a.push(d,M,v,f,l,y)}const i=t+1;for(let n=0;n<s;n++)for(let o=0;o<t;o++){const h=n*i+o,u=n*i+o+1,p=(n+1)*i+o,r=(n+1)*i+o+1;n!==0&&e.push(h,r,u),n!==s-1&&e.push(h,p,r)}return{vertices:new Float32Array(a),indices:new Uint16Array(e)}}function A(c=16){const t=[],s=[];t.push(0,1,0,0,1,0);for(let i=0;i<c;i++){const n=i/c*Math.PI*2,o=Math.sin(n),h=Math.cos(n);t.push(o,1,h,0,1,0)}for(let i=0;i<c;i++)s.push(0,i+1,(i+1)%c+1);const a=t.length/6;t.push(0,-1,0,0,-1,0);for(let i=0;i<c;i++){const n=i/c*Math.PI*2,o=Math.sin(n),h=Math.cos(n);t.push(o,-1,h,0,-1,0)}for(let i=0;i<c;i++)s.push(a,a+(i+1)%c+1,a+i+1);const e=t.length/6;for(let i=0;i<=c;i++){const n=i/c*Math.PI*2,o=Math.sin(n),h=Math.cos(n);t.push(o,1,h,o,0,h),t.push(o,-1,h,o,0,h)}for(let i=0;i<c;i++){const n=e+i*2,o=e+i*2+1,h=e+(i+1)*2,u=e+(i+1)*2+1;s.push(n,o,u),s.push(n,u,h)}return{vertices:new Float32Array(t),indices:new Uint16Array(s)}}function w(c){return{I:[[-1.5,.5,.5],[-.5,.5,.5],[.5,.5,.5],[1.5,.5,.5]],J:[[-1.5,1.5,.5],[-1.5,.5,.5],[-.5,.5,.5],[.5,.5,.5]],L:[[1.5,1.5,.5],[1.5,.5,.5],[.5,.5,.5],[-.5,.5,.5]],O:[[-.5,1.5,.5],[.5,1.5,.5],[-.5,.5,.5],[.5,.5,.5]],S:[[.5,1.5,.5],[-.5,1.5,.5],[-.5,.5,.5],[-1.5,.5,.5]],T:[[-.5,1.5,.5],[-1.5,.5,.5],[-.5,.5,.5],[.5,.5,.5]],Z:[[-1.5,1.5,.5],[-.5,1.5,.5],[-.5,.5,.5],[.5,.5,.5]]}[c]}function P(c){const t=w(c);if(!t)throw new Error("Unknown tetris type");const s=_(),a=s.vertices.length/6,e=a*4,i=new Float32Array(e*6),n=s.indices.length,o=new Uint16Array(n*4);let h=0,u=0,p=0;for(let r of t)h+=r[0],u+=r[1],p+=r[2];h/=4,u/=4,p/=4;for(let r=0;r<4;r++){const d=t[r],M=(d[0]-h)*1,v=(d[1]-u)*1,f=(d[2]-p)*1;for(let l=0;l<a;l++){let y=s.vertices[l*6+0]*.5,x=s.vertices[l*6+1]*.5,z=s.vertices[l*6+2]*.5;i[(r*a+l)*6+0]=y+M,i[(r*a+l)*6+1]=x+v,i[(r*a+l)*6+2]=z+f,i[(r*a+l)*6+3]=s.vertices[l*6+3],i[(r*a+l)*6+4]=s.vertices[l*6+4],i[(r*a+l)*6+5]=s.vertices[l*6+5]}for(let l=0;l<n;l++)o[r*n+l]=s.indices[l]+r*a}return{vertices:i,indices:o}}class g{constructor(t,s={}){this.canvas=t,this.target=s.target||[0,.5,0],this.radius=s.radius||14,this.minRadius=s.minRadius||2,this.maxRadius=s.maxRadius||200,this.theta=s.theta||0,this.phi=s.phi||Math.PI/4,this.rotateSpeed=s.rotateSpeed||.005,this.zoomSpeed=s.zoomSpeed||.0015,this.panSpeed=s.panSpeed||.001,this._dragging=!1,this._dragButton=0,this._last=[0,0],this._initEvents()}_initEvents(){this.canvas.addEventListener("pointerdown",t=>{this._dragging=!0,this._dragButton=t.button,this._last=[t.clientX,t.clientY],this.canvas.setPointerCapture(t.pointerId),t.preventDefault()}),this.canvas.addEventListener("contextmenu",t=>{t.preventDefault()}),this.canvas.addEventListener("pointerup",t=>{this._dragging=!1,this.canvas.releasePointerCapture(t.pointerId)}),this.canvas.addEventListener("pointermove",t=>{if(!this._dragging)return;const s=t.clientX-this._last[0],a=t.clientY-this._last[1];if(this._last=[t.clientX,t.clientY],this._dragButton===0){this.theta-=s*this.rotateSpeed,this.phi-=a*this.rotateSpeed;const e=.001;this.phi=Math.max(e,Math.min(Math.PI-e,this.phi))}else(this._dragButton===1||this._dragButton===2)&&this.pan(-s,a)}),this.canvas.addEventListener("wheel",t=>{t.preventDefault();const s=Math.exp(t.deltaY*this.zoomSpeed);this.radius=Math.min(this.maxRadius,Math.max(this.minRadius,this.radius*s))},{passive:!1})}pan(t,s){const a=Math.sin(this.phi)*Math.sin(this.theta),e=Math.cos(this.phi),i=Math.sin(this.phi)*Math.cos(this.theta),n=[a,e,i],o=[0,1,0];let h=o[1]*n[2]-o[2]*n[1],u=o[2]*n[0]-o[0]*n[2],p=o[0]*n[1]-o[1]*n[0];const r=Math.hypot(h,u,p);r>1e-4&&(h/=r,u/=r,p/=r);let d=n[1]*p-n[2]*u,M=n[2]*h-n[0]*p,v=n[0]*u-n[1]*h;const f=this.panSpeed*this.radius;this.target[0]+=(h*t+d*s)*f,this.target[1]+=(u*t+M*s)*f,this.target[2]+=(p*t+v*s)*f}getViewProj(t){const s=Math.PI/4,a=.1,e=200,i=1/Math.tan(s/2),n=new Float32Array([i/t,0,0,0,0,i,0,0,0,0,e/(a-e),-1,0,0,e*a/(a-e),0]),o=Math.sin(this.phi)*Math.sin(this.theta)*this.radius+this.target[0],h=Math.cos(this.phi)*this.radius+this.target[1],u=Math.sin(this.phi)*Math.cos(this.theta)*this.radius+this.target[2],p=[o,h,u],r=this.lookAt(p,this.target,[0,1,0]);return this.multiplyMat4ColumnMajor(r,n)}lookAt(t,s,a){const e=this.normalize([t[0]-s[0],t[1]-s[1],t[2]-s[2]]),i=this.normalize(this.cross(a,e)),n=this.cross(e,i);return new Float32Array([i[0],n[0],e[0],0,i[1],n[1],e[1],0,i[2],n[2],e[2],0,-this.dot(i,t),-this.dot(n,t),-this.dot(e,t),1])}normalize(t){const s=Math.hypot(t[0],t[1],t[2]);return s>0?[t[0]/s,t[1]/s,t[2]/s]:[0,0,0]}cross(t,s){return[t[1]*s[2]-t[2]*s[1],t[2]*s[0]-t[0]*s[2],t[0]*s[1]-t[1]*s[0]]}dot(t,s){return t[0]*s[0]+t[1]*s[1]+t[2]*s[2]}multiplyMat4ColumnMajor(t,s){const a=new Float32Array(16);for(let e=0;e<4;e++)for(let i=0;i<4;i++)a[e+i*4]=t[0+i*4]*s[e+0*4]+t[1+i*4]*s[e+1*4]+t[2+i*4]*s[e+2*4]+t[3+i*4]*s[e+3*4];return a}}export{g as O,_ as a,A as b,m as c,P as d,w as g};
